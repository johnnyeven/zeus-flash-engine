///////////////////////////////////////////////////////////
//  CWorldMap.as
//  Macromedia ActionScript Implementation of the Class CWorldMap
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:55
//  Original author: Administrator
///////////////////////////////////////////////////////////

/**
 * 使用流程
 * 1. 实例化CWorldMap
 * 2. 添加一个MapEvent.MAP_DATA_LOADED事件侦听器
 * 3. 调用loadMapData()
 * 4. 处理MapEvent.MAP_DATA_LOADED事件
 * 4-1. 调用initBuffer() 初始化缓冲区
 * 4-2. 构造一个Shape赋予CWorldMap.displayBuffer
 * 4-3. 将这个Shape添加进舞台做最终的显示
 * 4-4. 调用init() 显示地图
 */

package apollo.maps
{
	import apollo.objects.CActionObject;
	import apollo.utils.loader.CLoaderEx;
	import apollo.algorithms.SilzAstar;
	import apollo.controller.Action;
	import apollo.utils.CXYArray;
	import apollo.events.MapEvent;
	import apollo.configuration.*;
	
	import flash.display.Bitmap;
	import flash.display.BitmapData;
	import flash.display.Loader;
	import flash.display.LoaderInfo;
	import flash.display.Shape;
	import flash.events.ErrorEvent;
	import flash.events.Event;
	import flash.events.EventDispatcher;
	import flash.events.IEventDispatcher;
	import flash.events.IOErrorEvent;
	import flash.geom.Matrix;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.net.URLLoader;
	import flash.net.URLRequest;

	/**
	 * @author Administrator
	 * @version 1.0
	 * @created 15-二月-2012 10:17:55
	 */

	public class CWorldMap implements IEventDispatcher
	{
		public var MapId: String = 'default';
		private var mapPath: String;
		private var roadMapPath: String;
		private var alphaMapPath: String;
		private var thumbnailMapPath: String;
		private static var _astar: SilzAstar;
		private var _urlLoader: URLLoader;
		/**
		 * 地图缓冲区（源地图）
		 */
		private var _buffer: BitmapData;
		/**
		 * 地图绘制区（用于显示）
		 */
		private var _displayBuffer: Shape;
		/**
		 * 用于判断地图是否移动以决定是否需要渲染
		 */
		private var _pre_center: CXYArray;
		/**
		 * 用于判断是否需要加载新的Tiles
		 */
		private var _pre_start: CXYArray;
		/**
		 * 居中显示坐标
		 */
		private var _center: CXYArray;
		/**
		 * 移动的终点目标
		 */
		private var _target: CXYArray;
		/**
		 * 地图卷动速度（单位：像素）
		 */
		private var _speed: uint = 10;
		/**
		 * 不能走的区块, true为可移动, false为不可移动
		 */
		private var _negativePath: Array;
		private var _mapReady: Boolean;
		private var _smallMapReady: Boolean;
		private var _roadMapReady: Boolean;
		private var _alphaMapReady: Boolean;
		//大地图缓存
		protected var _mapCache: BitmapData;
		//缩略图
		protected var _smallMap: BitmapData;
		protected var _smallMapCache: BitmapData;
		/**
		 * 透明碰撞检测位图
		 */
		private var _alphaMap: BitmapData;
		/**
		 * 屏幕左上角对应的地图实际坐标X
		 */
		private var _screenStartX: int;
		/**
		 * 屏幕左上角对应的地图实际坐标Y
		 */
		private var _screenStartY: int;
		protected var eventDispatcher: EventDispatcher;
		
		private var _cameraView: Rectangle = new Rectangle();
		private var _cameraCutView: Rectangle = new Rectangle();
		
		/**
		 * 当前屏幕内容纳的最大地图碎片数量
		 */
		private var _screenTileNum: CXYArray;
		
		/**
		 * 只加载图片 不显示的开关
		 */
		private var _prepareLoadTile: Boolean;
		
		/**
		 *  镜头跟随的目标
		 */
		private var focus:CActionObject;
		
		protected var _mapXMLData: XML;
		
		public function CWorldMap()
		{
			_pre_center = new CXYArray();
			_pre_start = new CXYArray(-1, -1);
			_center = new CXYArray();
			_target = new CXYArray();
			_screenTileNum = new CXYArray();
			eventDispatcher = new EventDispatcher(this);
			_prepareLoadTile = false;
			_mapReady = false;
			_smallMapReady = false;
			_roadMapReady = false;
			_alphaMapReady = false;
		}
		
		public function get mapXMLData(): XML
		{
			return _mapXMLData;
		}
		
		public function get smallMap(): BitmapData
		{
			return _smallMap;
		}
		
		public function get center(): CXYArray
		{
			if (focus != null)
			{
				_center.x = focus.pos.x;
				_center.y = focus.pos.y;
			}
			return _center;
		}
		
		public function set center(_pos: CXYArray): void
		{
			_pos.x = Math.max(_pos.x, GlobalContextConfig.Width / 2);
			_pos.x = Math.min(_pos.x, MapContextConfig.MapSize.x - GlobalContextConfig.Width / 2);
			
			_pos.y = Math.max(_pos.y, GlobalContextConfig.Height / 2);
			_pos.y = Math.min(_pos.y, MapContextConfig.MapSize.y- GlobalContextConfig.Height / 2);
			
			this._center = _pos;
		}
		
		public function pointToCenter(_pos: CXYArray): CXYArray
		{
			_pos.x = Math.max(_pos.x, GlobalContextConfig.Width / 2);
			_pos.x = Math.min(_pos.x, MapContextConfig.MapSize.x - GlobalContextConfig.Width / 2);
			
			_pos.y = Math.max(_pos.y, GlobalContextConfig.Height / 2);
			_pos.y = Math.min(_pos.y, MapContextConfig.MapSize.y- GlobalContextConfig.Height / 2);
			
			return _pos;
		}
		
		/**
		 * 计算屏幕左上角对应的实际地图坐标X
		 */
		protected function get screenStartX(): int
		{
			var _screenStartX: int = center.x - int(GlobalContextConfig.Width / 2);
			_screenStartX = Math.max(0, _screenStartX);
			_screenStartX = Math.min(MapContextConfig.MapSize.x - GlobalContextConfig.Width, _screenStartX);
			return _screenStartX;
		}
		
		/**
		 * 计算屏幕左上角对应的实际地图坐标Y
		 */
		protected function get screenStartY(): int
		{
			var _screenStartY: int = center.y - int(GlobalContextConfig.Height / 2);
			_screenStartY = Math.max(0, _screenStartY);
			_screenStartY = Math.min(MapContextConfig.MapSize.y - GlobalContextConfig.Height, _screenStartY);
			return _screenStartY;
		}
		
		/**
		 * 计算镜头剪裁区域左上角对应实际地图坐标X
		 */
		protected function get cutviewStartX(): int
		{
			var _cutviewStartX: int = screenStartX - MapContextConfig.TileSize.x;
			_cutviewStartX = Math.max(0, _cutviewStartX);
			return _cutviewStartX;
		}
		
		/**
		 * 计算镜头剪裁区域左上角对应实际地图坐标Y
		 */
		protected function get cutviewStartY(): int
		{
			var _cutviewStartY: int = screenStartY - MapContextConfig.TileSize.y;
			_cutviewStartY = Math.max(0, _cutviewStartY);
			return _cutviewStartY;
		}

		/**
		 * 镜头显示的区域
		 */
		public function get cameraView(): Rectangle
		{
			_cameraView.x = screenStartX > MapContextConfig.MapSize.x - GlobalContextConfig.Width ? MapContextConfig.MapSize.x - GlobalContextConfig.Width : screenStartX;
			_cameraView.y = screenStartY > MapContextConfig.MapSize.y - GlobalContextConfig.Height ? MapContextConfig.MapSize.y - GlobalContextConfig.Height : screenStartY;
			
			_cameraView.width = GlobalContextConfig.Width;
			_cameraView.height = GlobalContextConfig.Height;
			
			return _cameraView;
		}

		/**
		 * 镜头剪裁区域视野
		 */
		public function get cameraCutView(): Rectangle
		{
			_cameraCutView.x = cutviewStartX;
			_cameraCutView.y = cutviewStartY;
			_cameraCutView.width = center.x < MapContextConfig.TileSize.x + GlobalContextConfig.Width / 2 ? center.x + GlobalContextConfig.Width / 2 + MapContextConfig.TileSize.x : GlobalContextConfig.Width + MapContextConfig.TileSize.x * 2;
			_cameraCutView.height = center.y < MapContextConfig.TileSize.y + GlobalContextConfig.Height / 2 ? center.y + GlobalContextConfig.Height / 2 + MapContextConfig.TileSize.y : GlobalContextConfig.Height + MapContextConfig.TileSize.y * 2;
			_cameraCutView.width = cutviewStartX > MapContextConfig.MapSize.x - (GlobalContextConfig.Width + MapContextConfig.TileSize.x * 2) ? MapContextConfig.MapSize.x - cutviewStartX : _cameraCutView.width;
			_cameraCutView.height = cutviewStartY > MapContextConfig.MapSize.y - (GlobalContextConfig.Width + MapContextConfig.TileSize.y * 2) ? MapContextConfig.MapSize.y - cutviewStartY : _cameraCutView.height;
			
			return _cameraCutView;
		}

		public function get nagetivePath(): Array
		{
			return _negativePath;
		}

		public static function get AStar(): SilzAstar
		{
			return _astar;
		}
		
		/**
		 * 设置镜头跟随某目标
		 */
		public function follow(o: CActionObject, cancel: Boolean = false): void
		{
			if (cancel)
			{
				if (focus != null)
				{
					focus.beFocus = false;
				}
				focus = null;
				return;
			}
			if (focus != null)
			{
				focus.beFocus = false;
				
				if (o == null)
				{
					_center.x = center.x;
					_center.y = center.y;
				}
			}
			
			focus = o;
			if (o != null)
			{
				o.beFocus = true;
			}
			
			render(true);
		}
		
		public function get follower(): CActionObject
		{
			return focus;
		}
		 
		/**
		 * 读取地图配置
		 */
		public function loadMapData(): void
		{
			var mapConfig: String = SocketContextConfig.resource_server_ip + GlobalContextConfig.MAP_RES_PATH + MapId + '/map.xml';
			var loader: URLLoader = new URLLoader();
			loader.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader.addEventListener(Event.COMPLETE, configMapData);
			loader.load(new URLRequest(mapConfig));
		}

		/**
		 * 
		 * @param _pos
		 */
		public function isPathAvailable(_pos:Point): Boolean
		{
			if (_pos.x >= MapContextConfig.BlockNum.x || _pos.y >= MapContextConfig.BlockNum.y)
			{
				return false;
			}
			else
			{
				return _negativePath[_pos.x][_pos.y];
			}
		}
		
		public function loadAlphaMap(): void
		{
			if (_alphaMap != null)
			{
				_alphaMap.dispose();
				_alphaMap = null;
			}
			
			var loader:Loader = new Loader();
			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, configAlphaMap);
			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader.load(new URLRequest(SocketContextConfig.resource_server_ip + GlobalContextConfig.MAP_RES_PATH + MapId + '/' + alphaMapPath));
		}
		
		private function configAlphaMap(event: Event): void
		{
			var loader: Loader = (event.target as LoaderInfo).loader;
			_alphaMap = (loader.content as Bitmap).bitmapData;
			
			loader.unload();
			loader.contentLoaderInfo.removeEventListener(Event.COMPLETE, configAlphaMap);
			loader.contentLoaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader = null;
			
			_alphaMapReady = true;
			if (_mapReady && _alphaMapReady && _roadMapReady && _smallMapReady) {
				dispatchEvent(new MapEvent(MapEvent.MAP_DATA_LOADED));
			}
		}
		
		public function loadRoadMap(): void
		{
			var loader: Loader = new Loader();
			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, configRoadMap);
			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader.load(new URLRequest(SocketContextConfig.resource_server_ip + GlobalContextConfig.MAP_RES_PATH + MapId + '/' + roadMapPath));
		}
		
		private function configRoadMap(event: Event): void
		{
			var loader: LoaderInfo = event.target as LoaderInfo;
			
			loader.removeEventListener(Event.COMPLETE, configRoadMap);
			loader.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
			
			resetRoadPath();
			var roadMap: BitmapData = (loader.content as Bitmap).bitmapData;
			
			var percentage: Number = roadMap.width / MapContextConfig.MapSize.x;
			var width: uint = int(MapContextConfig.MapSize.x / MapContextConfig.BlockSize.x);
			var height: uint = int(MapContextConfig.MapSize.y / MapContextConfig.BlockSize.y);
			
			for (var y: uint = 0; y < height; y++)
			{
				for (var x: uint = 0; x < width; x++)
				{
					_negativePath[y][x] = roadMap.getPixel32(int(MapContextConfig.BlockSize.x * x * percentage), int(MapContextConfig.BlockSize.y * y * percentage)) == 0x00000000 ? true : false;
				}
			}
			roadMap.dispose();
			setupAstar();
			
			_roadMapReady = true;
			if (_mapReady && _alphaMapReady && _roadMapReady && _smallMapReady) {
				dispatchEvent(new MapEvent(MapEvent.MAP_DATA_LOADED));
			}
		}
		
		public function loadMap(): void
		{
			var loader: Loader = new Loader();
			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, configMap);
			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader.load(new URLRequest(SocketContextConfig.resource_server_ip + GlobalContextConfig.MAP_RES_PATH + MapId + '/' + mapPath));
		}
		
		private function configMap(event: Event): void
		{
			var loader: LoaderInfo = event.target as LoaderInfo;
			
			loader.removeEventListener(Event.COMPLETE, configRoadMap);
			loader.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
			
			_mapCache = (loader.content as Bitmap).bitmapData;
			
			_mapReady = true;
			if (_mapReady && _alphaMapReady && _roadMapReady && _smallMapReady) {
				dispatchEvent(new MapEvent(MapEvent.MAP_DATA_LOADED));
			}
		}
		
		private function setupAstar(): void
		{
			_astar = new SilzAstar(_negativePath);
		}
		
		protected function resetRoadPath(): void
		{
			if (_negativePath != null)
			{
				_negativePath.splice(0, _negativePath.length);
				_negativePath = null;
			}
			_negativePath = new Array();
			
			var width: uint = int(MapContextConfig.MapSize.x / MapContextConfig.BlockSize.x) + 1;
			var height: uint = int(MapContextConfig.MapSize.y / MapContextConfig.BlockSize.y) + 1;
			
			for (var y: uint = 0; y < height; y++)
			{
				var temp: Array = new Array();
				for (var x: uint = 0; x < width; x++)
				{
					temp.push(true);
				}
				_negativePath.push(temp);
			}
		}
		
		public function isInAlphaArea(x: uint, y: uint): Boolean
		{
			if (_alphaMap == null)
			{
				return false;
			}
			return _alphaMap.getPixel32(int(_alphaMap.width / MapContextConfig.MapSize.x * x), int(_alphaMap.height / MapContextConfig.MapSize.y * y)) != 0x00000000;
		}

		/**
		 * 根据屏幕坐标获取在地图上的坐标
		 * 
		 * @param _pos
		 */
		public function getMapPosition(_pos:Point): Point
		{
			var result: Point = new Point();
			result.x = screenStartX + _pos.x;
			result.y = screenStartY + _pos.y;
			return result;
		}

		/**
		 * 根据地图坐标获取屏幕上的坐标
		 * 
		 * @param _pos
		 */
		public function getScreenPosition(_pos:Point): Point
		{
			var result: Point = new Point();
			result.x = _pos.x - screenStartX;
			result.y = _pos.y - screenStartY;
			return result;
		}

		/**
		 * 根据世界地图上的坐标转换为寻路格子的坐标
		 * 
		 * @param _pos
		 */
		public static function mapToBlockPosition(_pos:Point): Point
		{
			var result: Point = new Point();
			result.x = int(_pos.x / MapContextConfig.BlockSize.x);
			result.y = int(_pos.y / MapContextConfig.BlockSize.y);
			return result;
		}

		/**
		 * 根据寻路格子的坐标获取世界地图上的坐标
		 * 
		 * @param _pos
		 */
		public static function blockToMapPosition(_pos:Point): Point
		{
			var result: Point = new Point();
			result.x = _pos.x * MapContextConfig.BlockSize.x + MapContextConfig.BlockSize.x * .5;
			result.y = _pos.y * MapContextConfig.BlockSize.y + MapContextConfig.BlockSize.y * .5;
			return result;
		}

		/**
		 * 
		 * @param _data
		 */
		public function set displayBuffer(_data:Shape): void
		{
			_displayBuffer = _data;
			_displayBuffer.graphics.beginBitmapFill(_buffer);
			_displayBuffer.graphics.drawRect(0, 0, _buffer.width, _buffer.height);
		}

		public function render(enforceRender: Boolean = false): void
		{
			if (!enforceRender && (focus != null && focus.action == Action.STOP))
			{
				return;
			}
			if (_center.x == _pre_center.x && _center.y == _pre_center.y)
			{
				return;
			}
			else
			{
				_displayBuffer.x = -screenStartX;
				_displayBuffer.y = -screenStartY;
				//渲染结束
				_pre_center.x = _center.x;
				_pre_center.y = _center.y;
			}
		}
		
		/**
		 * 动态计算需要读取的地图碎片
		 */
		private function prepareRenderData(): void
		{
			var startX: int = int(screenStartX / MapContextConfig.TileSize.x);
			var startY: int = int(screenStartY / MapContextConfig.TileSize.y);
			
			if (startX == _pre_start.x && startY == _pre_start.y)
			{
				return;
			}
			else
			{
				var maxX: int = Math.min(startX + _screenTileNum.x, MapContextConfig.TileNum.x);
				var maxY: int = Math.min(startY + _screenTileNum.y, MapContextConfig.TileNum.y);
				
				var preparedX: int = startX * MapContextConfig.TileSize.x;
				var preparedY: int = startY * MapContextConfig.TileSize.y;
				
				if (!_prepareLoadTile)
				{
					_pre_start.x = startX;
					_pre_start.y = startY;
				}
				loadMapFromCache(0, 0, MapContextConfig.MapSize.x, MapContextConfig.MapSize.y);
			}
		}
		
		public function loadMapFromCache(x: int, y: int, width: int = 0, height: int = 0): void
		{
			if (width == 0)
			{
				width = cameraCutView.width;
			}
			if (height == 0)
			{
				height = cameraCutView.height;
			}
			_buffer.draw(_mapCache, new Matrix(), null, null, null, true);
			_displayBuffer.cacheAsBitmap = true;
			if (_prepareLoadTile)
			{
				_prepareLoadTile = false;
			}
			dispatchEvent(new MapEvent(MapEvent.MAP_LOADED));
		}
		
		/**
		 * 用缩略图临时填充
		 */
		protected function drawThumbnail(startX: int, startY: int): void
		{
			if (_smallMap == null || _smallMapCache == null)
			{
				return;
			}
			var per: Number = _smallMap.width / MapContextConfig.MapSize.x;
			_smallMapCache.fillRect(_smallMapCache.rect, 0);
			var rect: Rectangle = new Rectangle(startX * MapContextConfig.TileSize.x * per, startY * MapContextConfig.TileSize.y * per, _smallMapCache.width, _smallMapCache.height);
			_smallMapCache.copyPixels(_smallMap, rect, new Point());
			
			per = MapContextConfig.MapSize.x / _smallMap.width;
			_buffer.draw(_smallMapCache, new Matrix(per, 0, 0, per), null, null, null, true);
		}

		/**
		 * 重置地图，首先Clear
		 */
		public function reset(): void
		{
			clear();
			_buffer.fillRect(_buffer.rect, 0);
		}

		/**
		 * 清空地图配置
		 */
		private function clear(): void
		{
			_mapXMLData = null;
			_negativePath.splice(0, _negativePath.length);
		}
		
		/**
		 * 初始化缓冲区
		 */
		public function initBuffer(): void
		{
			//初始化缓冲区
			_buffer = new BitmapData(MapContextConfig.MapSize.x, MapContextConfig.MapSize.y, false);
		}

		/**
		 * 初始化地图
		 */
		public function init(): void
		{
			var per: Number = _smallMap.width / MapContextConfig.MapSize.x;
			_smallMapCache = new BitmapData(_buffer.width * per, _buffer.height * per, false, 0);
			
			//预读地图碎片
			_prepareLoadTile = true;
			prepareRenderData();
		}
		
		/**
		 * 加载缩略图
		 * @param	e
		 */
		public function loadSmallMap(): void
		{
			//读取缩略图
			var mapThumbnail: String = SocketContextConfig.resource_server_ip + GlobalContextConfig.MAP_RES_PATH + MapId + '/' + thumbnailMapPath;
			var loader: Loader = new Loader();
			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onSmallMapLoaded);
			loader.load(new URLRequest(mapThumbnail));
		}

		/**
		 * 缩略图加载完成，处理缩略图
		 * 
		 * @param e
		 */
		public function onSmallMapLoaded(e:Event): void
		{
			var loaderInfo: LoaderInfo = e.target as LoaderInfo;
			loaderInfo.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);
			loaderInfo.removeEventListener(Event.COMPLETE, onSmallMapLoaded);
			
			_smallMap = (loaderInfo.content as Bitmap).bitmapData;
			
			loaderInfo.loader.unload();
			loaderInfo = null;
			
			_smallMapReady = true;
			if (_mapReady && _alphaMapReady && _roadMapReady && _smallMapReady) {
				dispatchEvent(new MapEvent(MapEvent.MAP_DATA_LOADED));
			}
		}
		
		/**
		 * IO错误处理函数
		 * 
		 * @param	e
		 */
		private function onIOError(e:IOErrorEvent): void
		{
			trace(e.text);
		}

		/**
		 * 地图数据加载完成，处理数据
		 * 
		 * @param e
		 */
		private function configMapData(e:Event): void
		{
			_mapXMLData = new XML();
			_mapXMLData.ignoreComments = true;
			_mapXMLData = XML(e.target.data);
			
			if (_mapXMLData.id != MapId)
			{
				dispatchEvent(new IOErrorEvent(IOErrorEvent.VERIFY_ERROR));
			}
			else
			{
				mapPath = _mapXMLData.path.data;
				roadMapPath = _mapXMLData.path.road;
				alphaMapPath = _mapXMLData.path.alpha;
				//缩略图地址
				thumbnailMapPath = _mapXMLData.path.thumbnail;
				//地图大小
				MapContextConfig.MapSize.x = parseInt(_mapXMLData.width);
				MapContextConfig.MapSize.y = parseInt(_mapXMLData.height);
				//地图碎片大小
				MapContextConfig.TileSize.x = parseInt(_mapXMLData.tileWidth);
				MapContextConfig.TileSize.y = parseInt(_mapXMLData.tileHeight);
				//地图碎片数量
				MapContextConfig.TileNum.x = Math.floor(MapContextConfig.MapSize.x / MapContextConfig.TileSize.x);
				MapContextConfig.TileNum.y = Math.floor(MapContextConfig.MapSize.y / MapContextConfig.TileSize.y);
				//寻路格子大小
				MapContextConfig.BlockSize.x = parseInt(_mapXMLData.blockWidth);
				MapContextConfig.BlockSize.y = parseInt(_mapXMLData.blockHeight);
				//寻路格子数量
				MapContextConfig.BlockNum.x = int(MapContextConfig.MapSize.x / MapContextConfig.BlockSize.x);
				MapContextConfig.BlockNum.y = int(MapContextConfig.MapSize.y / MapContextConfig.BlockSize.y);
				//屏幕内容纳的最大碎片数量
				_screenTileNum.x = Math.ceil(GlobalContextConfig.Width / MapContextConfig.TileSize.x) + 2;
				_screenTileNum.y = Math.ceil(GlobalContextConfig.Height / MapContextConfig.TileSize.y) + 2;
				//设置X、Y轴上的速度修正量
				//MapContextConfig.xFixNum = Math.cos(Math.atan2(parseInt(_mapXMLData.radiansOffsetY) , parseInt(_mapXMLData.radiansOffsetX)));
				//MapContextConfig.yFixNum = Math.cos(Math.atan2(parseInt(_mapXMLData.radiansOffsetX) , parseInt(_mapXMLData.radiansOffsetY)));
				
				//设置初始点
				//var centerPos: CXYArray = new CXYArray(CharacterData.PosX, CharacterData.PosY);
				var centerPos: CXYArray = new CXYArray(parseInt(_mapXMLData.startPointX), parseInt(_mapXMLData.startPointY));
				center = centerPos;
				
				loadSmallMap();
				loadAlphaMap();
				loadRoadMap();
				loadMap();
			}
		}

		/**
		 * 
		 * @param type
		 * @param listener
		 * @param useCapture
		 * @param priority
		 * @param useWeakReference
		 */
		public function addEventListener(type:String, listener:Function, useCapture:Boolean = false, priority:int = 0, useWeakReference:Boolean = false): void
		{
			eventDispatcher.addEventListener(type, listener, useCapture, priority, useWeakReference);
		}

		/**
		 * 
		 * @param e
		 */
		public function dispatchEvent(e:Event): Boolean
		{
			return eventDispatcher.dispatchEvent(e);
		}

		/**
		 * 
		 * @param type
		 */
		public function hasEventListener(type:String): Boolean
		{
			return eventDispatcher.hasEventListener(type);
		}

		/**
		 * 
		 * @param type
		 * @param listener
		 * @param useCapture
		 */
		public function removeEventListener(type:String, listener:Function, useCapture:Boolean = false): void
		{
			eventDispatcher.removeEventListener(type, listener, useCapture);
		}

		/**
		 * 
		 * @param type
		 */
		public function willTrigger(type:String): Boolean
		{
			return eventDispatcher.willTrigger(type);
		}

	} //end CWorldMap

}
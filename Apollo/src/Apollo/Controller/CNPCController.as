///////////////////////////////////////////////////////////
//  CNPCController.as
//  Macromedia ActionScript Implementation of the Class CNPCController
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:55
//  Original author: Administrator
///////////////////////////////////////////////////////////

package Apollo.Controller
{
	import Apollo.Controller.CBaseController;
	import Apollo.Objects.CCharacterObject;
	import Apollo.Objects.CNPCCharacter;
	import Apollo.Maps.CWorldMap;
	import Apollo.Objects.CDirection;
	import Apollo.Network.CControlConnection;

	import flash.geom.Point;
	
	/**
	 * @author Administrator
	 * @version 1.0
	 * @created 15-二月-2012 10:17:55
	 */

	public class CNPCController extends CBaseController implements IControllerMovable
	{
		protected var _path: Array;
		private var _step: uint = 1;
		private var _isLoop: Boolean = false;
		
		private var _prevFollowPoint: Point;

		public function CNPCController(per: CPerception)
		{
			super(per);
			_prevFollowPoint = new Point();
		}
		
		public function moveTo(x: Number, y: Number): void
		{
			var currentObject: CNPCCharacter = _controlObject as CNPCCharacter;
			var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			if (node == null)
			{
				return;
			}
			else
			{
				_path = new Array();
				for (var i: uint = 0; i < node.length; i++)
				{
					_path.push([node[i].x, node[i].y]);
				}
			}
			
			_step = 1;
		}
		
		public function moveKeepDistance(x: Number, y: Number, distance: Number = -1): void
		{
			if (distance <= 0)
			{
				moveTo(x, y);
				return;
			}
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			//计算路径
			var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			if (node == null)
			{
				return;
			}
			else
			{
				_path = new Array();
				for (var i: uint = 0; i < node.length; i++)
				{
					_path.push([node[i].x, node[i].y]);
				}
			}
			
			_step = 1;
		}
		
		private function getNearestPathIndex(node: Array, x: Number, y: Number, distance: Number): uint
		{
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			for (var i: uint = node.length - 1; i >= 0; i--)
			{
				if (currentObject.follow != null)
				{
					if (Point.distance(node[i], currentObject.follow.pos) > distance)
					{
						return i;
					}
				}
				else
				{
					if (Point.distance(node[i], new Point(x, y)) > distance)
					{
						return i;
					}
				}
			}
			return 0;
		}
		
		public function set loopPath(value: Boolean): void
		{
			_isLoop = value;
		}
		
		override public function calcAction(): void
		{
			var controlObject: CNPCCharacter = _controlObject as CNPCCharacter;
			if (controlObject.isFollow)
			{
				var followNextPoint: Point = controlObject.follow.pos;
				if (followNextPoint == null)
				{
					return;
				}
				if (Point.distance(followNextPoint, _prevFollowPoint) > 50 &&
				Point.distance(followNextPoint, controlObject.pos) > 50)
				{
					moveTo(followNextPoint.x, followNextPoint.y);
					_prevFollowPoint.x = followNextPoint.x;
					_prevFollowPoint.y = followNextPoint.y;
					trace(_prevFollowPoint);
				}
				/*
				if (controlObject.followDirection != controlObject.follow.direction)
				{
					controlObject.followDistance.x = controlObject.followDistance.x * -1;
					controlObject.followDirection = controlObject.follow.direction;
				}
				_nextPoint = new Point(followNextPoint.x + controlObject.followDistance.x, followNextPoint.y + controlObject.followDistance.y);
				if (controlObject.pos == _nextPoint)
				{
					return;
				}
				*/
			}
			if (_path != null && _path[_step] != null)
			{
				_nextPoint = _step == _path.length ? _endPoint : CWorldMap.blockToMapPosition(new Point(_path[_step][0], _path[_step][1]));
			}
			if (_nextPoint != null && _nextPoint != controlObject.pos)
			{
				if (!controlObject.inUse)
				{
					controlObject.setPos(_nextPoint);
					_step++;
					if (_path != null && _step >= _path.length)
					{
						if (_isLoop)
						{
							_step = 0;
						}
						else
						{
							_nextPoint = null;
							controlObject.action = Action.STOP;
						}
					}
					return;
				}
				else
				{
					var radians: Number = CDirection.getRadians(_nextPoint.x - controlObject.pos.x, _nextPoint.y - controlObject.pos.y);
					var angle: Number = CDirection.radiansToDegress(radians) + 90;
					
					var readyX: Boolean = false;
					var readyY: Boolean = false;
					
					var speedX: Number = controlObject.speed * Math.cos(radians);
					var speedY: Number = controlObject.speed * Math.sin(radians);
					
					if (Math.abs(controlObject.pos.x - _nextPoint.x) <= speedX)
					{
						readyX = true;
						speedX = 0;
					}
					if (Math.abs(controlObject.pos.y - _nextPoint.y) <= speedY)
					{
						readyY = true;
						speedY = 0;
					}
					
					move(controlObject.pos.x + speedX, controlObject.pos.y + speedY, controlObject);
					
					if (readyX && readyY)
					{
						_step++;
						controlObject.setPos(_nextPoint);
						if (_path != null && _step >= _path.length)
						{
							if (_isLoop)
							{
								_step = 0;
							}
							else
							{
								_nextPoint = null;
								_path.splice(0, _path.length);
								_path = null;
							}
						}
						controlObject.action = Action.STOP;
					}
					else
					{
						changeDirectionByAngle(angle);
					}
				}
			}
		}
		
		protected function move(nextX: Number, nextY: Number, controlObject: CNPCCharacter): void
		{
			controlObject.setPos(new Point(nextX, nextY));
			
			if (controlObject.action != Action.DIE)
			{
				controlObject.action = Action.MOVE;
			}
		}
	} //end CNPCController

}
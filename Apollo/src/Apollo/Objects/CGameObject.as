///////////////////////////////////////////////////////////
//  CGameObject.as
//  Macromedia ActionScript Implementation of the Class CGameObject
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:54
//  Original author: johnnyeven
///////////////////////////////////////////////////////////

package Apollo.Objects
{
	import Apollo.Scene.*;
	import Apollo.utils.CStaticObject;
	import Apollo.Graphics.CGraphicResource;
	import Apollo.Controller.CBaseController;
	import Apollo.Renders.CRender;
	import Apollo.Network.Command.sending.Send_Info_ChangeDirection;
	import Apollo.Center.CCommandCenter;
	
	import flash.display.Bitmap;
	import flash.geom.Point;
	import flash.geom.Rectangle;
	import flash.events.Event;
	import flash.system.System;

	/**
	 * @author johnnyeven
	 * @version 1.0
	 * @created 15-二月-2012 10:17:54
	 */

	public class CGameObject extends CStaticObject
	{
		protected var _graphic: CGraphicResource;
		protected var _renderBuffer: Bitmap;
		//protected var _scriptAction: CScriptAction;
		public var canBeAttack: Boolean = false;
		protected var _className: String;
		protected var _controller: CBaseController;
		/**
		 * 方向，即素材的行数
		 */
		protected var _direction: uint;
		/**
		 * 渲染开始点
		 */
		private var _renderPos: uint;
		/**
		 * 渲染的矩形大小
		 */
		protected var _rect: Rectangle;
		public var objectId: String;
		public var objectName: String;
		protected var _pos: Point;
		protected var _render: CRender;
		protected var _speed: uint = 0;
		protected var _zIndex: uint = 0;
		public var inUse: Boolean = false;
		public var beFocus: Boolean = false;
		protected var _zIndexOffset: uint = 0;
		/**
		 * 静止状态下（站立、坐下、死亡）是否需要渲染
		 */
		public var staticUpdate: Boolean = false;
		
		private static const CENTER: uint = 0;
		private static const TOP_LEFT: uint = 1;
		private static const BOTTOM_LEFT: uint = 2;

		public function CGameObject(_ctrl: CBaseController = null, _direction: uint = CDirection.DOWN)
		{
			changeController(_ctrl);
			this._direction = _direction;
			_renderPos = TOP_LEFT;
			_rect = new Rectangle();
			_pos = new Point();
			initBuffer();
		}
		
		public function changeController(_ctrl: CBaseController): void
		{
			if (_controller != null)
			{
				_controller.removeListener();
			}
			if (_ctrl != null)
			{
				_controller = _ctrl;
				_controller.controlObject = this;
				_controller.setupListener();
			}
		}
		
		protected function initBuffer(): void
		{
			_renderBuffer = new Bitmap();
			addChild(_renderBuffer);
		}

		public function get graphic(): CGraphicResource
		{
			return _graphic;
		}
		
		public function set graphic(gr: CGraphicResource): void
		{
			_graphic = gr;
			rebuild();
		}
		
		public function get render(): CRender
		{
			return _render;
		}
		
		public function set render(r: CRender): void
		{
			_render = r;
		}

		public function get renderBuffer(): Bitmap
		{
			return _renderBuffer;
		}
/*
		public function get action(): CScriptAction
		{
		}
*/
		/**
		 * 
		 * @param _ctrl
		 */

		/**
		 * 
		 * @param className
		 */
		public function set className(className:String): void
		{
			_className = className;
		}

		public function get className(): String
		{
			return _className;
		}
		
		public function get controller(): CBaseController
		{
			return _controller;
		}
		
		public function get angle(): uint
		{
			switch(_direction)
			{
				case CDirection.DOWN:
					return 180;
				case CDirection.LEFT:
					return 270;
				case CDirection.TOP:
					return 0;
				case CDirection.RIGHT:
					return 90;
				default:
					return 90;
			}
		}
		
		public function set direction(d: uint): void
		{
			_direction = d;
			if (CApolloScene.getInstance().player == this)
			{
				CCommandCenter.commandChangeDirection(_direction);
			}
		}
		
		public function get direction(): uint
		{
			return _direction;
		}

		/**
		 * 
		 * @param pos
		 */
		public function setPos(pos:Point): void
		{
			_pos.x = pos.x;
			_pos.y = pos.y;
			_zIndex = pos.y;
		}

		public function get pos(): Point
		{
			return _pos;
		}

		/**
		 * 
		 * @param _script
		 * @param _function
		 * @param _param
		 */
		public function ProcessScript(_script:String, _function:String, _param:Array): Boolean
		{
			return true;
		}

		public function RenderObject(): void
		{
			if (_renderBuffer != null && inUse)
			{
				_render.render(this);
			}
		}

		/**
		 * 
		 * @param _speed
		 */
		public function set speed(_speed:uint): void
		{
			this._speed = _speed;
		}

		public function get speed(): uint
		{
			return _speed;
		}

		public function get zIndex(): uint
		{
			return _zIndex + _zIndexOffset;
		}

		public function Upgrade(): void
		{
		}

		/**
		 * 
		 * @param zIndexOffset
		 */
		public function get zIndexOffset(): uint
		{
			return _zIndexOffset;
		}

		/**
		 * 
		 * @param zIndexOffset
		 */
		public function set zIndexOffset(zIndexOffset:uint): void
		{
			_zIndexOffset = zIndexOffset;
		}
		
		public function get renderRect(): Rectangle
		{
			_rect.x = 0;
			_rect.y = 0;
			_rect.width = _graphic.frameWidth;
			_rect.height = _graphic.frameHeight;
			return _rect;
		}
		
		public function get renderLine(): uint
		{
			return 0;
		}
		
		public function get renderFrame(): uint
		{
			return 0;
		}
		
		protected function rebuild(): void
		{
			setBufferPos();
		}
		
		public function setBufferPos(x: Number = NaN, y: Number = NaN): void
		{
			if (!isNaN(x) && !isNaN(y))
			{
				_renderBuffer.x = -x;
				_renderBuffer.y = -y;
			}
			else if (_graphic != null)
			{
				_renderBuffer.x = -_graphic.frameWidth / 2;
				_renderBuffer.y = -_graphic.frameHeight + 10;
			}
		}
		
		public function isMovingOut(callback: Function = null): void
		{
			if (hasEventListener(Event.ENTER_FRAME))
			{
				removeEventListener(Event.ENTER_FRAME, goIn);
			}
			if (!hasEventListener(Event.ENTER_FRAME))
			{
				addEventListener(Event.ENTER_FRAME, goOut);
			}
			if (callback != null)
			{
				addEventListener(Event.COMPLETE, callback);
			}
		}
		
		public function isMovingIn(callback: Function = null): void
		{
			if (hasEventListener(Event.ENTER_FRAME))
			{
				removeEventListener(Event.ENTER_FRAME, goOut);
			}
			if (!hasEventListener(Event.ENTER_FRAME))
			{
				addEventListener(Event.ENTER_FRAME, goIn);
			}
			if (callback != null)
			{
				addEventListener(Event.COMPLETE, callback);
			}
		}
		
		protected function goOut(event: Event): void
		{
			if (alpha > 0)
			{
				alpha -= .05;
			}
			else
			{
				removeEventListener(Event.ENTER_FRAME, isMovingOut);
				dispatchEvent(new Event(Event.COMPLETE));
			}
		}
		
		protected function goIn(event: Event): void
		{
			if (alpha < 1)
			{
				alpha += .05;
			}
			else
			{
				removeEventListener(Event.ENTER_FRAME, isMovingIn);
				dispatchEvent(new Event(Event.COMPLETE));
			}
		}
		
		public function destroy(event: Event = null): void
		{
			if (_graphic != null)
			{
				_graphic.clear();
				_graphic = null;
			}
			
			if (!inUse)
			{
				if (_controller != null)
				{
					_controller.perception.scene.removeObject(this);
					_controller.perception.scene.ctrlCenter.removeController(_controller);
					_controller = null;
				}
				_render = null;
				canBeAttack = false;
			}
			else
			{
				inUse = false;
				isMovingOut(destroy);
			}
			
			System.gc();
		}
	} //end CGameObject

}
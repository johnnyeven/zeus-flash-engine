///////////////////////////////////////////////////////////
//  CNPCController.as
//  Macromedia ActionScript Implementation of the Class CNPCController
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:55
//  Original author: Administrator
///////////////////////////////////////////////////////////

package Apollo.Controller
{
	import Apollo.Objects.*;
	import Apollo.Controller.CBaseController;
	import Apollo.Maps.CWorldMap;
	import Apollo.Events.ControllerEvent;
	import Apollo.Network.CControlConnection;
	import Apollo.utils.Vector2D;
	import Apollo.Configuration.*;

	import flash.geom.Point;
	
	/**
	 * @author Administrator
	 * @version 1.0
	 * @created 15-二月-2012 10:17:55
	 */

	public class CMonsterController extends CBaseController implements IControllerMovable
	{
		protected var _path: Array;
		private var _step: uint = 1;
		private var _isLoop: Boolean = false;
		
		private var _prevFollowPoint: Point;

		protected var _lastAttackTime: uint;
		
		public function CMonsterController(per: CPerception)
		{
			super(per);
			_prevFollowPoint = new Point();
		}
		
		override public function clear(): void
		{
			var controlObject: CMonsterCharacter = _controlObject as CMonsterCharacter;
			controlObject.follow = null;
			controlObject.attacker = null;
			_path = null;
			_nextPoint = null;
			_endPoint = null;
		}
		
		public function moveTo(x: Number, y: Number): void
		{
			var currentObject: CMonsterCharacter = _controlObject as CMonsterCharacter;
			//计算路径
			try
			{
				var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			}
			catch (err: Error)
			{
				return;
			}
			if (node == null)
			{
				return;
			}
			else
			{
				_path = new Array();
				for (var i: uint = 0; i < node.length; i++)
				{
					_path.push([node[i].x, node[i].y]);
				}
			}
			
			_step = 1;
		}
		
		public function moveKeepDistance(x: Number, y: Number, distance: Number = -1): void
		{
			var currentObject: CMonsterCharacter = _controlObject as CMonsterCharacter;
			if (currentObject.attacker != null)
			{
				if (Point.distance(currentObject.pos, (currentObject.attacker as CBattleObject).pos) <= distance)
				{
					return;
				}
			}
			else
			{
				return;
			}
			if (distance <= 0)
			{
				moveTo(x, y);
				return;
			}
			//计算路径
			try
			{
				var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			}
			catch (err: Error)
			{
				return;
			}
			if (node == null)
			{
				return;
			}
			else
			{
				var index: int = getNearestPathIndex(node, x, y, distance);
				var newNode: Point;
				if (index != -1)
				{
					var vector: Vector2D;
					var temp: Point = CWorldMap.blockToMapPosition(new Point(node[index].x, node[index].y));
					var temp2: Point = CWorldMap.blockToMapPosition(new Point(node[index + 1].x, node[index + 1].y));
					if (index >= node.length -1)
					{
						vector = new Vector2D(temp.x - (currentObject.attacker as CBattleObject).pos.x, temp.y - (currentObject.attacker as CBattleObject).pos.y);
					}
					else
					{
						vector = new Vector2D(temp.x - temp2.x, temp.y - temp2.y);
					}
					vector.length = distance - 10;
					
					newNode = CWorldMap.mapToBlockPosition(new Point(temp2.x + vector.x, temp2.y + vector.y));
				}
				else
				{
					moveKeepDistance((currentObject.attacker as CBattleObject).pos.x, (currentObject.attacker as CBattleObject).pos.y, distance);
					return;
				}
				
				_path = new Array();
				for (var i: uint = 0; i <= index; i++)
				{
					_path.push([node[i].x, node[i].y]);
					if (i == index)
					{
						_path.push([newNode.x, newNode.y]);
					}
				}
			} 
			
			_step = 1;
		}
		
		private function getNearestPathIndex(node: Array, x: Number, y: Number, distance: Number): int
		{
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			for (var i: int = node.length - 1; i >= 0; i--)
			{
				var temp: Point = CWorldMap.blockToMapPosition(new Point(node[i].x, node[i].y));
				if (currentObject.attacker != null)
				{
					if (Point.distance(temp, (currentObject.attacker as CBattleObject).pos) > distance)
					{
						return i;
					}
				}
				else
				{
					if (Point.distance(temp, new Point(x, y)) > distance)
					{
						return i;
					}
				}
			}
			return -1;
		}
		
		public function set loopPath(value: Boolean): void
		{
			_isLoop = value;
		}
		
		override public function calcAction(): void
		{
			var controlObject: CMonsterCharacter = _controlObject as CMonsterCharacter;
			if (controlObject.isFollow)
			{
				var followNextPoint: Point = controlObject.follow.pos;
				if (followNextPoint == null)
				{
					return;
				}
				if (Point.distance(followNextPoint, _prevFollowPoint) > 50 &&
				Point.distance(followNextPoint, controlObject.pos) > 50)
				{
					moveKeepDistance(followNextPoint.x, followNextPoint.y, controlObject.attackRange);
					_prevFollowPoint.x = followNextPoint.x;
					_prevFollowPoint.y = followNextPoint.y;
				}
			}
			if (_path != null && _path[_step] != null)
			{
				_nextPoint = _step == _path.length ? _endPoint : CWorldMap.blockToMapPosition(new Point(_path[_step][0], _path[_step][1]));
			}
			if (_nextPoint != null && _nextPoint != controlObject.pos)
			{
				if (!controlObject.inUse)
				{
					controlObject.setPos(_nextPoint);
					_step++;
					if (_path != null && _step >= _path.length)
					{
						if (_isLoop)
						{
							_step = 0;
						}
						else
						{
							_nextPoint = null;
							controlObject.action = Action.STOP;
							eventDispatcher.dispatchEvent(new ControllerEvent(ControllerEvent.MOVE_INTO_POSITION));
						}
					}
					return;
				}
				else
				{
					var radians: Number = CDirection.getRadians(_nextPoint.x - controlObject.pos.x, _nextPoint.y - controlObject.pos.y);
					var angle: Number = CDirection.radiansToDegress(radians) + 90;
					
					var readyX: Boolean = false;
					var readyY: Boolean = false;
					
					var speedX: Number = controlObject.speed * Math.cos(radians);
					var speedY: Number = controlObject.speed * Math.sin(radians);
					
					if (Math.abs(controlObject.pos.x - _nextPoint.x) <= speedX)
					{
						readyX = true;
						speedX = 0;
					}
					if (Math.abs(controlObject.pos.y - _nextPoint.y) <= speedY)
					{
						readyY = true;
						speedY = 0;
					}
					
					move(controlObject.pos.x + speedX, controlObject.pos.y + speedY, controlObject);
					
					if (readyX && readyY)
					{
						_step++;
						controlObject.setPos(_nextPoint);
						if (_path != null && _step >= _path.length)
						{
							if (_isLoop)
							{
								_step = 0;
							}
							else
							{
								_nextPoint = null;
								_path.splice(0, _path.length);
								_path = null;
							}
						}
						controlObject.action = Action.STOP;
						ifNeedAttack();
					}
					else
					{
						changeDirectionByAngle(angle);
					}
				}
			}
			calcBattle();
		}
		
		protected function ifNeedAttack(): void
		{
			var controlObject: CBattleObject = _controlObject as CBattleObject;
			if (controlObject.attacker != null)
			{
				controlObject.prepareAttack(controlObject.attacker);
			}
		}
		
		protected function calcBattle(): void
		{
			var controlObject: CBattleObject = _controlObject as CBattleObject;
			if (controlObject.attacker != null && controlObject.attacker.isDead)
			{
				controlObject.action = Action.STOP;
				controlObject.attacker = null;
				return;
			}
			if (controlObject.action == Action.ATTACK)
			{
				if (_lastAttackTime == 0)
				{
					_lastAttackTime = GlobalContextConfig.Timer - controlObject.attackCoolDown;
				}
				if (GlobalContextConfig.Timer - _lastAttackTime >= controlObject.attackCoolDown && Point.distance((controlObject.attacker as CBattleObject).pos, controlObject.pos) <= controlObject.attackRange + 50)
				{
					//_netConnection.attackRequest(controlObject.objectId, (controlObject.attacker as CBattleObject).objectId, 0);
					_lastAttackTime = GlobalContextConfig.Timer;
				}
				changeDirectionByPoint((controlObject.attacker as CGameObject).pos.x, (controlObject.attacker as CGameObject).pos.y);
			}
		}
		
		protected function move(nextX: Number, nextY: Number, controlObject: CMonsterCharacter): void
		{
			controlObject.setPos(new Point(nextX, nextY));
			
			if (controlObject.action != Action.DIE)
			{
				controlObject.action = Action.MOVE;
			}
		}
	} //end CNPCController

}
///////////////////////////////////////////////////////////
//  CCharacterController.as
//  Macromedia ActionScript Implementation of the Class CCharacterController
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:54
//  Original author: Administrator
///////////////////////////////////////////////////////////

package Apollo.Controller
{
	import Apollo.Events.*;
	import Apollo.Graphics.*;
	import Apollo.Network.CControlConnection;
	import Apollo.Network.Command.sending.*;
	import Apollo.Center.*;
	import Apollo.Objects.*;
	import Apollo.Objects.Effects.*;
	import Apollo.Configuration.*;
	import Apollo.Maps.CWorldMap;
	import Apollo.Renders.CRenderEffect;
	import Apollo.Scene.CWoohaScene;
	import Apollo.Script.CScript;
	import Apollo.utils.Vector2D;
	import Apollo.Controller.Skill.*;
	import Apollo.utils.CCharacterData;

	import flash.display.Stage;
	import flash.events.KeyboardEvent;
	import flash.events.MouseEvent;
	import flash.events.Event;
	import flash.geom.Point;
	
	/**
	 * @author Administrator
	 * @version 1.0
	 * @created 15-二月-2012 10:17:54
	 */

	public class CCharacterController extends CBaseController implements IControllerMovable
	{
		protected var target: Point;
		protected var _step: uint;
		protected var _path: Array;
		/**
		 * 控制方式
		 * 1 - 鼠标控制
		 * 2 - 键盘控制
		 * 0 - 鼠标键盘一起控制
		 */
		protected var controlType: uint;
		
		public static const MOUSE: uint = 1;
		public static const KEY: uint = 2;
		public static const KEY_AND_MOUSE: uint = 0;
		
		protected var key_w: Boolean;
		protected var key_a: Boolean;
		protected var key_s: Boolean;
		protected var key_d: Boolean;
		
		protected var _lastAttackTime: int;
		
		protected var _listenerSetuped: Boolean = false;
		
		protected var _preSyncTimer: uint;
		
		/**
		 * 当前按键
		 */
		protected var _currentKey: int;
		/**
		 * 当前正在使用的技能Id
		 */
		protected var _currentSkillId: String;
		/**
		 * 当前技能作用的目标（点）
		 */
		protected var _target: *;
		
		public function CCharacterController(per: CPerception, ctrlType: uint = MOUSE)
		{
			super(per);
			_step = 1;
			controlType = ctrlType;
			
			key_w = false;
			key_a = false;
			key_s = false;
			key_d = false;
			_lastAttackTime = 0;
			_preSyncTimer = GlobalContextConfig.Timer;
		}
		
		override public function set controlObject(o:CGameObject): void
		{
			super.controlObject = o;
			_skillController = new CSkill(_controlObject as CCharacterObject);
		}
		
		override public function setupListener(): void
		{
			if (!_listenerSetuped)
			{
				var stage: Stage = _perception.scene.stage;
				switch(controlType)
				{
					case KEY:
						setupKeyListener(stage);
						break;
					case MOUSE:
						setupMouseListener(stage);
						break;
					/*
					case KEY_AND_MOUSE:
						setupKeyListener(stage);
						setupMouseListener(stage);
					*/
				}
				_listenerSetuped = true;
				setupSkillHotkey(stage);
			}
		}
		
		protected function setupSkillHotkey(_stage: Stage): void
		{
			_stage.addEventListener(KeyboardEvent.KEY_DOWN, onSkillHotkeyDown, false, 0, true);
		}
		
		private function setupKeyListener(_stage: Stage): void
		{
			_stage.addEventListener(KeyboardEvent.KEY_DOWN, onKeyDown, false, 0, true);
			_stage.addEventListener(KeyboardEvent.KEY_UP, onKeyUp, false, 0, true);
		}
		
		private function setupMouseListener(_stage: Stage): void
		{
			_stage.addEventListener(MouseEvent.CLICK, onMouseClick, false, 0, true);
		}
		
		protected function onKeyDown(event: KeyboardEvent): void
		{
			switch(event.keyCode)
			{
				case 87:
				case 38:
					key_w = true;
					break;
				case 65:
				case 37:
					key_a = true;
					break;
				case 83:
				case 40:
					key_s = true;
					break;
				case 68:
				case 39:
					key_d = true;
					break;
			}
		}
		
		protected function onKeyUp(event: KeyboardEvent): void
		{
			switch(event.keyCode)
			{
				case 87:
				case 38:
					key_w = false;
					break;
				case 65:
				case 37:
					key_a = false;
					break;
				case 83:
				case 40:
					key_s = false;
					break;
				case 68:
				case 39:
					key_d = false;
					break;
			}
		}
		
		protected function onSkillHotkeyDown(event: KeyboardEvent): void
		{
			var controlObject: CCharacterObject = _controlObject as CCharacterObject;
			if (controlObject.locker != null)
			{
				_target = controlObject.locker;
			}
			else
			{
				var o: CGameObject = _perception.getClicker(_perception.scene.stage.mouseX, _perception.scene.stage.mouseY);
				if (o != null)
				{
					/*
					_target = o;
					controlObject.locker = o as CBattleObject;
					*/
					trace("no locker");
					return;
				}
				else
				{
					_target = _perception.scene.map.getMapPosition(new Point(_perception.scene.stage.mouseX, _perception.scene.stage.mouseY));
				}
			}
			
			//打断行走
			_path = new Array();
			(_controlObject as CActionObject).action = Action.STOP;
			
			switch(event.keyCode)
			{
				case KeyCode.F1:
					//判断是否是范围攻击
					if (SkillConfig.isRangeAttack(CharacterData.getInstance().skillList[KeyCode.F1][0]))
					{
						
					}
					else if(_target is Point)
					{
						return;
					}
					else
					{
						processAttack(KeyCode.F1);
					}
					break;
				case KeyCode.F2:
					//判断是否是范围攻击
					if (SkillConfig.isRangeAttack(CharacterData.getInstance().skillList[KeyCode.F2][0]))
					{
						
					}
					else if(_target is Point)
					{
						return;
					}
					else
					{
						processAttack(KeyCode.F2);
					}
					break;
				case KeyCode.F3:
					//判断是否是范围攻击
					if (SkillConfig.isRangeAttack(CharacterData.getInstance().skillList[KeyCode.F3][0]))
					{
						_skillController.showRangeAttack(event.keyCode);
						_skillController.addEventListener(SkillEvent.RANGE_SELECTED, onRangeAttackSelected);
					}
					else if(_target is Point)
					{
						return;
					}
					else
					{
						processAttack(KeyCode.F3);
					}
					break;
				case KeyCode.F4:
					//判断是否是范围攻击
					if (SkillConfig.isRangeAttack(CharacterData.getInstance().skillList[KeyCode.F4][0]))
					{
						
					}
					else if(_target is Point)
					{
						return;
					}
					else
					{
						processAttack(KeyCode.F4);
					}
					break;
				case KeyCode.F5:
					//判断是否是范围攻击
					if (SkillConfig.isRangeAttack(CharacterData.getInstance().skillList[KeyCode.F5][0]))
					{
						
					}
					else if(_target is Point)
					{
						return;
					}
					else
					{
						processAttack(KeyCode.F5);
					}
					break;
			}
		}
		
		protected function onRangeAttackSelected(event: SkillEvent): void
		{
			_target = _perception.scene.map.getMapPosition(event.data.point as Point);
			processAttack(event.data.keyCode);
		}
		
		protected function processAttack(keyCode: int): void
		{
			var controlObject: CCharacterObject = _controlObject as CCharacterObject;
			
			controlObject.render.render(controlObject, true);
			_currentKey = keyCode;
			_currentSkillId = CharacterData.getInstance().skillList[keyCode][0];
			
			var skillConfig: Object = SkillConfig.getSkillConfig(_currentSkillId);
			var skillLevel: int = CharacterData.getInstance().skillList[keyCode][1];
			
			controlObject.attackSpeed = 1000 / skillConfig.level[skillLevel].cdTime;
			controlObject.attackRange = skillConfig.level[skillLevel].distance;
			controlObject.prepareAttack(_target);
		}
		
		protected function onMouseClick(event: MouseEvent): void
		{
			if (!isStatic)
			{
				var currentObject: CCharacterObject = _controlObject as CCharacterObject;
				
				//检查是否点击某对象
				var o: CGameObject = _perception.getClicker(event.stageX, event.stageY);
				if (o != null)
				{
					//触发点击该对象的点击事件
					if (o is CNPCCharacter && Point.distance(o.pos, _controlObject.pos) < 300)
					{
						var target: CNPCCharacter = o as CNPCCharacter;
						target.script.triggerEvent(CScript.EVENT_CLICK);
					}
					else if (o is CBattleObject && o.canBeAttack)
					{
						//currentObject.prepareAttack(o);
						currentObject.locker = o as CBattleObject;
					}
					return;
				}
				//打断吟唱
				clearAttacker();
				currentObject.action = Action.STOP;
				
				var map: CWorldMap = _perception.scene.map;
				_endPoint = map.getMapPosition(new Point(event.stageX, event.stageY));
				
				//计算路径
				var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, _endPoint.x, _endPoint.y);
				if (node == null)
				{
					return;
				}
				else
				{
					_path = new Array();
					for (var i: uint = 0; i < node.length; i++)
					{
						_path.push([node[i].x, node[i].y]);
					}
				}
				_endPoint = CWorldMap.blockToMapPosition(new Point(_path[_path.length - 1][0], _path[_path.length - 1][1]));
				CCommandCenter.commandMoveTo(_endPoint.x, _endPoint.y);
				_step = 1;
			}
		}
		
		override public function clear(): void
		{
			var controlObject: CCharacterObject = _controlObject as CCharacterObject;
			controlObject.follow = null;
			controlObject.attacker = null;
			_path = null;
			_nextPoint = null;
			_endPoint = null;
		}
		
		protected function clearAttacker(): void
		{
			if ((_controlObject as CBattleObject).attacker != null)
			{
				(_controlObject as CBattleObject).attacker = null;
			}
		}
		
		public function moveTo(x: Number, y: Number): void
		{
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			//计算路径
			try
			{
				var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			}
			catch (err: Error)
			{
				return;
			}
			if (node == null)
			{
				return;
			}
			else
			{
				_path = new Array();
				for (var i: uint = 0; i < node.length; i++)
				{
					_path.push([node[i].x, node[i].y]);
				}
			}
			_endPoint = CWorldMap.blockToMapPosition(new Point(_path[_path.length - 1][0], _path[_path.length - 1][1]));
			CCommandCenter.commandMoveTo(_endPoint.x, _endPoint.y);
			_step = 1;
		}
		
		/**
		 * 只在follow不为空的情况下使用
		 * @param	x
		 * @param	y
		 * @param	distance
		 */
		public function moveKeepDistance(x: Number, y: Number, distance: Number = -1): void
		{
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			if (currentObject.attacker != null)
			{
				if (Point.distance(currentObject.pos, currentObject.attackerPosition) <= distance)
				{
					return;
				}
			}
			else
			{
				return;
			}
			if (distance <= 0)
			{
				moveTo(x, y);
				return;
			}
			//计算路径
			try
			{
				var node: Array = CWorldMap.AStar.find(currentObject.pos.x, currentObject.pos.y, x, y);
			}
			catch (err: Error)
			{
				return;
			}
			if (node == null)
			{
				return;
			}
			else
			{
				var index: int = getNearestPathIndex(node, x, y, distance);
				var newNode: Point;
				if (index != -1)
				{
					var vector: Vector2D;
					var temp: Point = CWorldMap.blockToMapPosition(new Point(node[index].x, node[index].y));
					var temp2: Point = CWorldMap.blockToMapPosition(new Point(node[index + 1].x, node[index + 1].y));
					if (index >= node.length -1)
					{
						vector = new Vector2D(temp.x - currentObject.attackerPosition.x, temp.y - currentObject.attackerPosition.y);
					}
					else
					{
						vector = new Vector2D(temp.x - temp2.x, temp.y - temp2.y);
					}
					vector.length = distance - 5;
					
					newNode = CWorldMap.mapToBlockPosition(new Point(temp2.x + vector.x, temp2.y + vector.y));
				}
				else
				{
					moveKeepDistance(currentObject.attackerPosition.x, currentObject.attackerPosition.y, distance);
					return;
				}
				
				_path = new Array();
				for (var i: uint = 0; i <= index; i++)
				{
					_path.push([node[i].x, node[i].y]);
					if (i == index)
					{
						_path.push([newNode.x, newNode.y]);
					}
				}
				_endPoint = CWorldMap.blockToMapPosition(new Point(_path[_path.length - 1][0], _path[_path.length - 1][1]));
				CCommandCenter.commandMoveTo(_endPoint.x, _endPoint.y);
			} 
			_step = 1;
		}
		
		/**
		 * 获取离目标点最近的攻击范围外的路径点的索引
		 * @param	node
		 * @param	x
		 * @param	y
		 * @param	distance
		 * @return
		 */
		private function getNearestPathIndex(node: Array, x: Number, y: Number, distance: Number): int
		{
			var currentObject: CCharacterObject = _controlObject as CCharacterObject;
			for (var i: int = node.length - 1; i >= 0; i--)
			{
				var temp: Point = CWorldMap.blockToMapPosition(new Point(node[i].x, node[i].y));
				if (currentObject.attacker != null)
				{
					if (Point.distance(temp, currentObject.attackerPosition) > distance)
					{
						return i;
					}
				}
				else
				{
					if (Point.distance(temp, new Point(x, y)) > distance)
					{
						return i;
					}
				}
			}
			return -1;
		}
		
		override public function calcAction(): void
		{
			switch(controlType)
			{
				case KEY:
					calcActionKey();
					break;
				case MOUSE:
					calcActionMouse();
					break;
			}
			syncPosition();
			calcBattle();
		}
		
		protected function calcBattle(): void
		{
			var controlObject: CBattleObject = _controlObject as CBattleObject;
			if (controlObject.attacker != null)
			{
				if (controlObject.attacker is CGameObject)
				{
					if (controlObject.attacker != null && controlObject.attacker.isDead)
					{
						controlObject.action = Action.STOP;
						controlObject.attacker = null;
						return;
					}
				}
				if (controlObject.action == Action.ATTACK)
				{
					if (GlobalContextConfig.Timer - _lastAttackTime >= controlObject.attackCoolDown)
					{
						var position: Point = controlObject.attackerPosition;
						changeDirectionByPoint(position.x, position.y);
						
						_lastAttackTime = GlobalContextConfig.Timer;
						_skillController.showSingEffect(_currentKey, _target);
						_skillController.addEventListener(SkillEvent.SING_COMPLETED, requestAttack);
					}
				}
			}
		}
		
		protected function requestAttack(event: SkillEvent): void
		{
			CCommandCenter.commandAttack(event.data.target, event.data.skillId);
		}
		
		protected function syncPosition(forceSync: Boolean = false): void
		{
			if (forceSync || (_path != null && _path[_step] != null && GlobalContextConfig.Timer - _preSyncTimer > GlobalContextConfig.sync_trigger))
			{
				CControllerCenter.getInstance().requestRefreshCamaraView();
				CCommandCenter.commandMoveSync(_controlObject.pos.x, _controlObject.pos.y);
				_preSyncTimer = GlobalContextConfig.Timer;
			}
		}
		
		protected function calcActionKey(): void
		{
			if (!isStatic)
			{
				var controlObject: CCharacterObject = _controlObject as CCharacterObject;
				var nextX: Number = controlObject.pos.x;
				var nextY: Number = controlObject.pos.y;
				
				if (key_a)
				{
					controlObject.direction = CDirection.LEFT;
					nextX -= controlObject.speed;
				}
				else if (key_d)
				{
					controlObject.direction = CDirection.RIGHT;
					nextX += controlObject.speed;
				}
				else if (key_s)
				{
					controlObject.direction = CDirection.DOWN;
					nextY += controlObject.speed;
				}
				else if (key_w)
				{
					controlObject.direction = CDirection.TOP;
					nextY -= controlObject.speed;
				}
				
				if (key_a && key_w)
				{
					controlObject.direction = CDirection.LEFT_TOP;
					nextX -= controlObject.speed * MapContextConfig.xFixNum;
					nextY -= controlObject.speed * MapContextConfig.yFixNum;
				}
				else if (key_w && key_d)
				{
					controlObject.direction = CDirection.RIGHT_TOP;
					nextX += controlObject.speed * MapContextConfig.xFixNum;
					nextY -= controlObject.speed * MapContextConfig.yFixNum;
				}
				else if (key_a && key_s)
				{
					controlObject.direction = CDirection.LEFT_DOWN;
					nextX -= controlObject.speed * MapContextConfig.xFixNum;
					nextY += controlObject.speed * MapContextConfig.yFixNum;
				}
				else if (key_d && key_s)
				{
					controlObject.direction = CDirection.RIGHT_DOWN;
					nextX += controlObject.speed * MapContextConfig.xFixNum;
					nextY += controlObject.speed * MapContextConfig.yFixNum;
				}
				
				if (!key_a && !key_d && !key_s && !key_w)
				{
					if (controlObject.action == Action.MOVE)
					{
						controlObject.action = Action.STOP;
					}
				}
				else
				{
					checkWalkable(nextX, nextY, controlObject);
				}
			}
		}
		
		protected function calcActionMouse(): void
		{
			if (!isStatic && _path != null && _path[_step] != null)
			{
				var controlObject: CCharacterObject = _controlObject as CCharacterObject;
				_nextPoint = _step == _path.length ? _endPoint : CWorldMap.blockToMapPosition(new Point(_path[_step][0], _path[_step][1]));
				
				var radians: Number = CDirection.getRadians(_nextPoint.x - controlObject.pos.x, _nextPoint.y - controlObject.pos.y);
				var angle: Number = CDirection.radiansToDegress(radians) + 90;
				
				var readyX: Boolean = false;
				var readyY: Boolean = false;
				
				var speedX: Number = controlObject.speed * Math.cos(radians);
				var speedY: Number = controlObject.speed * Math.sin(radians);
				
				if (Math.abs(controlObject.pos.x - _nextPoint.x) <= speedX)
				{
					readyX = true;
					speedX = 0;
				}
				if (Math.abs(controlObject.pos.y - _nextPoint.y) <= speedY)
				{
					readyY = true;
					speedY = 0;
				}
				
				move(controlObject.pos.x + speedX, controlObject.pos.y + speedY, controlObject);
				
				if (readyX && readyY)
				{
					_step++;
					if (_step >= _path.length)
					{
						controlObject.action = Action.STOP;
						_path = null;
						_step = 1;
						eventDispatcher.dispatchEvent(new ControllerEvent(ControllerEvent.MOVE_INTO_POSITION));
						syncPosition(true);
					}
				}
				else
				{
					changeDirectionByAngle(angle);
				}
			}
		}
		
		protected function checkWalkable(nextX: Number, nextY: Number, controlObject: CCharacterObject): void
		{
			if (nextX > MapContextConfig.MapSize.x || nextX < 0)
			{
				return;
			}
			if (nextY > MapContextConfig.MapSize.y || nextY < 0)
			{
				return;
			}
			
			var point: Point = CWorldMap.mapToBlockPosition(new Point(nextX, nextY));
			if (_perception.scene.map.nagetivePath[point.y][point.x] == undefined || _perception.scene.map.nagetivePath[point.y][point.x] != false)
			{
				return;
			}
			
			move(nextX, nextY, controlObject);
		}
		
		protected function move(nextX: Number, nextY: Number, controlObject: CCharacterObject): void
		{
			controlObject.setPos(new Point(nextX, nextY));
			
			if (controlObject.action != Action.DIE)
			{
				controlObject.action = Action.MOVE;
			}
		}
		
		protected function get isStatic(): Boolean
		{
			if (_controlObject == null)
			{
				return false;
			}
			if ((_controlObject as CCharacterObject).action == Action.DIE)
			{
				return true;
			}
			return false;
		}
		
		public function set lastAttackTime(value: int): void
		{
			_lastAttackTime = value;
		}
	} //end CCharacterController

}
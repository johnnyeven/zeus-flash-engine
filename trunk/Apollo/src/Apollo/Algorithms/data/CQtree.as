///////////////////////////////////////////////////////////
//  CQtree.as
//  Macromedia ActionScript Implementation of the Class CQtree
//  Generated by Enterprise Architect
//  Created on:      15-二月-2012 10:17:55
//  Original author: Administrator
///////////////////////////////////////////////////////////

package Apollo.Algorithms.data
{
	import flash.geom.Rectangle;

	/**
	 * @author Administrator
	 * @version 1.0
	 * @created 15-二月-2012 10:17:55
	 */

	public class CQtree
	{
		public var child1: CQtree;
		public var child2: CQtree;
		public var child3: CQtree;
		public var child4: CQtree;
		public var parent: CQtree;
		public var root: CQtree;
		public var rect: Rectangle;
		public var data: Array;

		public function CQtree(area: Rectangle, deep: uint = 6, _root: CQtree = null)
		{
			data = new Array();
			rect = area;
			if (_root != null)
			{
				this.root = _root;
			}
			else
			{
				this.root = this;
			}
			createChildren(deep);
		}

		/**
		 * 
		 * @param deep
		 */
		protected function createChildren(deep:uint): void
		{
			if (deep == 0)
			{
				return;
			}
			
			const hw: Number = rect.width / 2;
			const hh: Number = rect.height / 2;

			child1 = new CQtree(new Rectangle(rect.x + hw, rect.y, hw, hh), deep - 1, root);
			child2 = new CQtree(new Rectangle(rect.x + hw, rect.y + hh, hw, hh), deep - 1, root);
			child3 = new CQtree(new Rectangle(rect.x, rect.y + hh, hw, hh), deep - 1, root);
			child4 = new CQtree(new Rectangle(rect.x, rect.y, hw, hh), deep - 1, root);
			
			child1.parent = child2.parent = child3.parent = child4.parent = this;
		}

		public function get hasChildren(): Boolean
		{
			return child1 && child2 && child3 && child4;
		}

		/**
		 * 
		 * @param o
		 * @param x
		 * @param y
		 */
		public function add(o:Object, x:Number, y:Number): CQtree
		{
			if (!isIn(x, y))
			{
				return null;
			}
			
			if (hasChildren)
			{
				return child1.add(o, x, y) || child2.add(o, x, y) || child3.add(o, x, y) || child4.add(o, x, y);
			}
			else
			{
				data.push(o);
				return this;
			}
		}

		/**
		 * 
		 * @param o
		 * @param x
		 * @param y
		 */
		public function remove(o:Object, x:Number = NaN, y:Number = NaN): CQtree
		{
			if (!isIn(x, y))
			{
				return null;
			}
			
			if (hasChildren)
			{
				return child1.remove(o, x, y) || child2.remove(o, x, y) || child3.remove(o, x, y) || child4.remove(o, x, y);
			}
			else
			{
				var index: int = data.indexOf(o);
				if (index != -1)
				{
					data.splice(index, 1);
					return this;
				}
				else
				{
					return null;
				}
			}
		}

		/**
		 * 
		 * @param x
		 * @param y
		 */
		public function isIn(x:Number, y:Number): Boolean
		{
			return (isNaN(x) || x >= rect.x && x < rect.right) && (isNaN(y) || y >= rect.y && y < rect.bottom);
		}

		/**
		 * 
		 * @param o
		 * @param x
		 * @param y
		 */
		public function reCheck(o:Object, x:Number, y:Number): CQtree
		{
			if (!isIn(x, y))
			{
				var result: CQtree = root.add(o, x, y);
				if (result)
				{
					remove(o);
					return result;
				}
			}
			return this;
		}

		/**
		 * 
		 * @param rect
		 */
		public function getDataInRect(rect:Rectangle): Array
		{
			if (!this.rect.intersects(rect))
				return [];
			
			var result:Array = data.concat();
			if (hasChildren)
			{
				result.push.apply(null, child1.getDataInRect(rect));
				result.push.apply(null, child2.getDataInRect(rect));
				result.push.apply(null, child3.getDataInRect(rect));
				result.push.apply(null, child4.getDataInRect(rect));
			}
			return result;
		}

	} //end CQtree

}